/*!
 * Leaflet.PolylineDecorator - v1.7.0
 * https://github.com/bbecquet/Leaflet.PolylineDecorator
 * (c) 2014-2020 Benjamin Becquet
 */
(function(window, document, undefined) {
'use strict';

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.LeafletPolylineDecorator = {}));
}(this, (function (exports) { 'use strict';

  var version = "1.7.0";

  var L = typeof window !== "undefined" ? window.L : typeof global !== "undefined" ? global.L : null;
  if (!L) {
    throw new Error("Leaflet must be loaded before Leaflet.PolylineDecorator");
  }

  L.PolylineDecorator = L.LayerGroup.extend({
    initialize: function (latlngs, options) {
      L.LayerGroup.prototype.initialize.call(this);
      this._latlngs = latlngs;
      this._options = L.Util.extend({}, this.options, options);
      this._symbols = this._options.patterns || [];
      this._initSymbols();
    },

    _initSymbols: function () {
      var i, len;
      for (i = 0, len = this._symbols.length; i < len; i++) {
        this._addSymbol(this._symbols[i]);
      }
    },

    _addSymbol: function (options) {
      var symbol = options.symbol;
      // Check for both initialize (for custom symbols) and constructor (for arrowHead)
      // symbol.constructor should be a function (like L.Symbol.ArrowHead)
      if (!symbol || (typeof symbol.initialize !== 'function' && typeof symbol.constructor !== 'function')) {
        console.warn('_addSymbol: symbol check failed', { hasSymbol: !!symbol, hasInitialize: typeof symbol?.initialize, hasConstructor: typeof symbol?.constructor });
        return;
      }
      var latlngs = this._latlngs;
      if (L.Polyline && latlngs instanceof L.Polyline) {
        latlngs = latlngs.getLatLngs();
      }
      if (!Array.isArray(latlngs) || latlngs.length < 2) {
        console.warn('_addSymbol: latlngs check failed', { isArray: Array.isArray(latlngs), length: latlngs?.length });
        return;
      }
      var offset = this._parseOffset(options.offset || '0%');
      var repeat = this._parseRepeat(options.repeat || '100%');
      console.log('_addSymbol: offset=', offset, 'repeat=', repeat, 'latlngs.length=', latlngs.length);
      var positions = this._calculatePositions(latlngs, offset, repeat);
      console.log('_addSymbol: calculated positions count=', positions.length);
      var i, len, position, symbolInstance;
      for (i = 0, len = positions.length; i < len; i++) {
        position = positions[i];
        symbolInstance = new symbol.constructor(position, symbol.options);
        this.addLayer(symbolInstance);
      }
      console.log('_addSymbol: added', positions.length, 'symbols');
    },

    _parseOffset: function (offset) {
      if (typeof offset === 'number') {
        return offset;
      }
      var match = offset.toString().match(/^(\d+(?:\.\d+)?)(%)?$/);
      if (!match) {
        return 0;
      }
      return match[2] === '%' ? parseFloat(match[1]) / 100 : parseFloat(match[1]);
    },

    _parseRepeat: function (repeat) {
      if (typeof repeat === 'number') {
        return repeat;
      }
      var match = repeat.toString().match(/^(\d+(?:\.\d+)?)(%)?$/);
      if (!match) {
        return 100;
      }
      return match[2] === '%' ? parseFloat(match[1]) / 100 : parseFloat(match[1]);
    },

    _calculatePositions: function (latlngs, offset, repeat) {
      var positions = [];
      var totalLength = this._getPolylineLength(latlngs);
      var currentOffset = typeof offset === 'number' && offset < 1 ? offset * totalLength : offset;
      var repeatDistance = typeof repeat === 'number' && repeat < 1 ? repeat * totalLength : repeat;
      var currentDistance = currentOffset;
      while (currentDistance < totalLength) {
        var position = this._getPositionAtDistance(latlngs, currentDistance);
        if (position) {
          positions.push(position);
        }
        currentDistance += repeatDistance;
      }
      return positions;
    },

    _getPolylineLength: function (latlngs) {
      var length = 0;
      var i, len;
      for (i = 0, len = latlngs.length - 1; i < len; i++) {
        length += latlngs[i].distanceTo ? latlngs[i].distanceTo(latlngs[i + 1]) : 
                 this._latlngDistance(latlngs[i], latlngs[i + 1]);
      }
      return length;
    },

    _latlngDistance: function (latlng1, latlng2) {
      var R = 6371000;
      var dLat = (latlng2.lat - latlng1.lat) * Math.PI / 180;
      var dLon = (latlng2.lng - latlng1.lng) * Math.PI / 180;
      var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
              Math.cos(latlng1.lat * Math.PI / 180) * Math.cos(latlng2.lat * Math.PI / 180) *
              Math.sin(dLon / 2) * Math.sin(dLon / 2);
      var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    },

    _getPositionAtDistance: function (latlngs, distance) {
      var currentDistance = 0;
      var i, len, segmentLength, segmentDistance;
      for (i = 0, len = latlngs.length - 1; i < len; i++) {
        segmentLength = latlngs[i].distanceTo ? latlngs[i].distanceTo(latlngs[i + 1]) :
                       this._latlngDistance(latlngs[i], latlngs[i + 1]);
        if (currentDistance + segmentLength >= distance) {
          segmentDistance = distance - currentDistance;
          var ratio = segmentDistance / segmentLength;
          var lat = latlngs[i].lat + (latlngs[i + 1].lat - latlngs[i].lat) * ratio;
          var lng = latlngs[i].lng + (latlngs[i + 1].lng - latlngs[i].lng) * ratio;
          var bearing = this._getBearing(latlngs[i], latlngs[i + 1]);
          return {
            lat: lat,
            lng: lng,
            bearing: bearing
          };
        }
        currentDistance += segmentLength;
      }
      return null;
    },

    _getBearing: function (latlng1, latlng2) {
      var dLon = (latlng2.lng - latlng1.lng) * Math.PI / 180;
      var lat1 = latlng1.lat * Math.PI / 180;
      var lat2 = latlng2.lat * Math.PI / 180;
      var y = Math.sin(dLon) * Math.cos(lat2);
      var x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
      return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
    }
  });

  L.polylineDecorator = function (latlngs, options) {
    return new L.PolylineDecorator(latlngs, options);
  };

  L.Symbol = L.Symbol || {};
  L.Symbol.arrowHead = function (options) {
    return {
      constructor: L.Symbol.ArrowHead,
      options: L.Util.extend({}, {
        pixelSize: 10,
        headAngle: 60,
        pathOptions: {
          stroke: true,
          fill: true,
          weight: 2,
          color: '#3388ff',
          opacity: 1,
          fillColor: '#3388ff',
          fillOpacity: 1
        }
      }, options)
    };
  };

  L.Symbol.ArrowHead = L.Marker.extend({
    initialize: function (position, options) {
      var iconOptions = {
        iconSize: [0, 0],
        iconAnchor: [0, 0],
        className: 'leaflet-arrowhead-marker'
      };
      // Preserve the full position object (with bearing) before Leaflet converts it
      this._position = position;
      this._bearing = position.bearing;
      // Convert to LatLng for the marker base class
      var latlng = L.latLng(position.lat, position.lng);
      this._pixelSize = options.pixelSize || 10;
      this._headAngle = (options.headAngle || 60) * Math.PI / 180;
      this._pathOptions = options.pathOptions || {};
      L.Marker.prototype.initialize.call(this, latlng, { icon: L.divIcon(iconOptions) });
    },

    onAdd: function (map) {
      L.Marker.prototype.onAdd.call(this, map);
      this._map = map;
      this._createArrow();
    },

    onRemove: function (map) {
      if (this._arrowElement) {
        this._arrowElement.remove();
        this._arrowElement = null;
      }
      L.Marker.prototype.onRemove.call(this, map);
    },

    _createArrow: function () {
      if (!this._map || !this._position || (!this._position.bearing && !this._bearing)) {
        return;
      }
      var mapPane = this._map.getPane('overlayPane') || this._map.getPane();
      if (!mapPane) {
        return;
      }
      // Use stored bearing if available, otherwise use position.bearing
      var bearing = (this._bearing || this._position.bearing) * Math.PI / 180;
      var size = this._pixelSize;
      var angle = this._headAngle;
      // Use the marker's current LatLng position (Leaflet may have updated _position)
      var currentLatLng = this.getLatLng ? this.getLatLng() : (this._position.lat ? L.latLng(this._position.lat, this._position.lng) : this._position);
      var point = this._map.latLngToLayerPoint(currentLatLng);
      var x1 = point.x - size * Math.cos(bearing - angle / 2);
      var y1 = point.y - size * Math.sin(bearing - angle / 2);
      var x2 = point.x;
      var y2 = point.y;
      var x3 = point.x - size * Math.cos(bearing + angle / 2);
      var y3 = point.y - size * Math.sin(bearing + angle / 2);
      var path = 'M ' + x1 + ' ' + y1 + ' L ' + x2 + ' ' + y2 + ' L ' + x3 + ' ' + y3 + ' Z';
      if (!this._arrowElement) {
        this._arrowElement = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        this._arrowElement.setAttribute('class', 'leaflet-arrowhead-svg');
        this._arrowElement.style.position = 'absolute';
        this._arrowElement.style.pointerEvents = 'none';
        this._arrowPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        this._arrowElement.appendChild(this._arrowPath);
        mapPane.appendChild(this._arrowElement);
      }
      var color = this._pathOptions.color || '#3388ff';
      var weight = this._pathOptions.weight || 2;
      var opacity = this._pathOptions.opacity !== undefined ? this._pathOptions.opacity : 1;
      var fillColor = this._pathOptions.fillColor || color;
      var fillOpacity = this._pathOptions.fillOpacity !== undefined ? this._pathOptions.fillOpacity : 1;
      this._arrowPath.setAttribute('d', path);
      this._arrowPath.setAttribute('stroke', color);
      this._arrowPath.setAttribute('stroke-width', weight);
      this._arrowPath.setAttribute('opacity', opacity);
      this._arrowPath.setAttribute('fill', fillColor);
      this._arrowPath.setAttribute('fill-opacity', fillOpacity);
      var bounds = this._map.getBounds();
      var sw = this._map.latLngToLayerPoint(bounds.getSouthWest());
      var ne = this._map.latLngToLayerPoint(bounds.getNorthEast());
      this._arrowElement.setAttribute('width', Math.abs(ne.x - sw.x));
      this._arrowElement.setAttribute('height', Math.abs(ne.y - sw.y));
      this._arrowElement.setAttribute('viewBox', sw.x + ' ' + sw.y + ' ' + Math.abs(ne.x - sw.x) + ' ' + Math.abs(ne.y - sw.y));
      this._map.on('zoomend viewreset', this._updateArrow, this);
    },

    _updateArrow: function () {
      if (this._arrowElement) {
        this._arrowElement.remove();
        this._arrowElement = null;
      }
      this._createArrow();
    }
  });

  exports.version = version;

})));
})(window, document);

